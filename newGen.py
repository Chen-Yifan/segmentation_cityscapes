from keras.preprocessing.image import ImageDataGenerator
import os
import numpy as np
def center_crop(img, mask, random_crop_size):
    height, width = img.shape[0], img.shape[1]
    dy, dx = random_crop_size
    y = (height - dy)//2
    x = (width - dx)//2
    return img[y:(y+dy), x:(x+dx), :], mask[y:(y+dy), x:(x+dx), :]

def random_crop(img, mask, random_crop_size):
    # Note: image_data_format is 'channel_last'
    # assert img.shape[2] == 3
    height, width = img.shape[0], img.shape[1]
    dy, dx = random_crop_size
    x = np.random.randint(0, width - dx + 1)
    y = np.random.randint(0, height - dy + 1)
    return img[y:(y+dy), x:(x+dx), :], mask[y:(y+dy), x:(x+dx), :]

def crop_generator(batches, crop_size, random=True): # change to enable x and y together
    """Take as input a Keras ImageGen (Iterator) and generate random
    crops from the image batches generated by the original iterator.
    """
    while True:
        batch_x, batch_y = next(batches)
        batch_crop_x = np.zeros((batch_x.shape[0], crop_length, crop_length, 3))
        batch_crop_y = np.zeros((batch_y.shape[0], crop_length, crop_length, 2))
        for i in range(batch_x.shape[0]):
            if random:
                batch_crop_x[i], batch_crop_y[i] = random_crop(batch_x[i], batch_y[i], crop_size)
            else:
                batch_crop_x[i], batch_crop_y[i] = center_crop(batch_x[i], batch_y[i], crop_size)
        yield (batch_crop_x, batch_crop_y)


def dataGen(frame_path, mask_path, batch_size=1, epochs=1, shape=(1024,2048)):
    # Training path
    X_path= os.path.join(frame_path, 'train') # input image
    Y_path = os.path.join(mask_path, 'train') # ground-truth label

    h = shape[0] # image height
    w = shape[1] # image width

    # Train data generator
    x_gen_args = dict(
                    rescale = 1./255,
                    rotation_range=0.2,
                    width_shift_range=0.05,
                    height_shift_range=0.05,
                    shear_range=0.05,
                    zoom_range=0.05,
                    horizontal_flip=True,
                    fill_mode='wrap')

    y_gen_args = dict(
                    rotation_range=0.2,
                    width_shift_range=0.05,
                    height_shift_range=0.05,
                    shear_range=0.05,
                    zoom_range=0.05,
                    horizontal_flip=True,
                    fill_mode='wrap')

    img_datagen = ImageDataGenerator(**x_gen_args)
    mask_datagen = ImageDataGenerator(**y_gen_args)

    seed = 1 # the same seed is applied to both image_ and mask_generator
    image_generator = img_datagen.flow_from_directory(
        X_path,
        target_size=(h, w),
        batch_size=batch_size,
        shuffle = True, # shuffle the training data
        class_mode=None, # set to None, in this case
        interpolation='bilinear',
        seed=seed)

    mask_generator = mask_datagen.flow_from_directory(
        Y_path,
        target_size=(h, w),
        color_mode='grayscale',
        batch_size=batch_size,
        shuffle = True,
        class_mode=None,
        interpolation='nearest',
        seed=seed)
    
    # combine image_ and mask_generator into one
    train_generator = zip(image_generator, mask_generator)
    train_crops = crop_generator(train_generator, (512,1024), random=True)
    num_train = len(image_generator)
    
    return train_crops, num_train


def val_dataGen(frame_path, mask_path, split, batch_size=1, epochs=1, shape=(1024,2048)):
    h = shape[0] # image height
    w = shape[1] # image width

    # Validation path
    val_X_path = os.path.join(frame_path, split)
    val_Y_path = os.path.join(mask_path, split)

    # val data generator
    image_datagen = ImageDataGenerator(rescale = 1./255)
    mask_datagen = ImageDataGenerator()
    seed = 1
    image_generator = image_datagen.flow_from_directory(
        val_X_path,
        target_size=(h, w),
        batch_size=batch_size,
        class_mode=None,
        interpolation='bilinear',
        shuffle = False, # we dont need to shuffle validation set
        seed=seed)

    mask_generator = mask_datagen.flow_from_directory(
        val_Y_path,
        target_size=(h, w),
        color_mode='grayscale',
        batch_size=batch_size,
        shuffle = False,
        class_mode=None,
        interpolation='nearest',
        seed=seed)

    val_generator = zip(image_generator, mask_generator)
    val_crops = crop_generator(val_generator, (512,1024), random=False)
    num_val = len(image_generator)

    return val_crops, num_val
